<!DOCTYPE html>
<html>
    <head>
    <meta http-equiv="content-language" content="en">
    <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Continuous Profiling Go applications running in Kubernetes</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="Kube-Profefe is an open source project that acts like a bridge between Kubernetes and Profefe. It helps you to implement continuous profiling for Go applications running in Kubernetes.">
    <meta name="keywords" content="golang, pprof, profefe, kubernetes">
    <meta name="google-site-verification" content="FoOIQ005srOjHlH19pNWapHvlOOVgCqHsz47IfQ6QNo" />
    <link rel="canonical" href="https://gianarb.it/blog/continuous-profiling-go-apps-in-kubernetes">
    <link rel="icon" type="image/png" href="/img/favicon.png" />

    <meta name='twitter:card' content='summary_large_image'>
    <meta name='twitter:title' content="Continuous Profiling Go applications running in Kubernetes">
    <meta name='twitter:description' content="Kube-Profefe is an open source project that acts like a bridge between Kubernetes and Profefe. It helps you to implement continuous profiling for Go applications running in Kubernetes.">

    <meta property="og:title" content="Continuous Profiling Go applications running in Kubernetes" />
    <meta property="og:site_name" content="gianarb blog"/>
    <meta property="og:url" content="https://gianarb.it/blog/continuous-profiling-go-apps-in-kubernetes" />
    <meta property="og:description" content="Kube-Profefe is an open source project that acts like a bridge between Kubernetes and Profefe. It helps you to implement continuous profiling for Go applications running in Kubernetes." />
    <meta property="og:type" content="article" />
    <meta property="og:locale" content="en_US" />

    <meta property="og:image" content="https://gianarb.it/img/profefe.png" />
    <meta name='twitter:image' content="https://gianarb.it/img/profefe.png">



    <meta property="twitter:account_id" content="129952408" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@gianarb">
    <meta name="twitter:creator" content="@gianarb">
    <meta name="twitter:title" content="Continuous Profiling Go applications running in Kubernetes">
    <meta name="twitter:description" content="Kube-Profefe is an open source project that acts like a bridge between Kubernetes and Profefe. It helps you to implement continuous profiling for Go applications running in Kubernetes.">
    <meta name="twitter:image:src" content="https://gianarb.it/img/profefe.png">
    <meta name="twitter:image:width" content="500">
    <meta name="twitter:image:height" content="500">
    <meta name="twitter:domain" content="gianarb.it">

    <link rel='alternate' type='application/atom+xml' title='Atom 0.3' href='/atom.xml'>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github.min.css" rel="stylesheet">

    <!-- source https://github.com/rsms/inter/ -->
    <link href="/fonts/inter/inter-ui.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/main.css">

</head>

    <body>
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark" role="navigation">
    <div class="container-fluid">
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>

      <div class="navbar-brand" href="#">
        <a href="/" class="nav-link">
          <img src="/img/favicon.png" class="img-fluid d-inline-block align-top" alt="">
        </a>
      </div>

      <div class="collapse navbar-collapse">
        <ul class="navbar-nav">
          <li><a class="nav-link" href="/">Home</a></li>
          <li><a class="nav-link" href="/blog.html">Blog</a></li>
          <li class="nav-item"><a href="/conferences.html" class="nav-link">Conferences</a></li>
        </ul>

        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7DLK7L&placement=gianarbit" id="_carbonads_js"></script>
          </li>
        </ul>

      </div>

    </div>
</nav>

        

<div class="container">

    <div class="content">

        <div class="row">
            <div id="post-title" class="mt-5 col-md-12">
                <h1>Continuous Profiling Go applications running in Kubernetes</h1>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <p class="meta">04 Feb 2020 · <!-- thanks to https://www.davidputney.com/2016/07/how-medium-style-read-time-estimate.html -->


<span class="blog-read-time">Eight minute read</span>
 · golang, pprof, profefe, kubernetes</p>
            </div>
        </div>

        <div class="row">
            <div class="col-md-12">
                <div class="addthis_sharing_toolbox"></div>
            </div>
        </div>

        <div class="row mt-3">
            <div class="col-md-12">
            <p>Recently I wrote <a href="https://gianarb.it/blog/go-continuous-profiling-profefe">“Continuous profiling in Go with
Profefe”</a>, an article
about the new shiny open source project I am contributing to.</p>

<p><strong>TLDR:</strong> Profefe is a registry for pprof profiles. You can push them embedding
an SDK in your application or you can write a collector (cronjob) that gets
profiles and push the tar via the Profefe API. Side by side with the profile you
have to send other information like:</p>

<ul>
  <li>Type: represents the profile type such as mutex, goroutines, CPU and so on</li>
  <li>Service: identifies the source for this profile, for example, the binary name</li>
  <li>InstanceID: identifies where it comes from, for example, pod name or server
hostname</li>
  <li>Labels: are optional key/value pairs that you can use at query time to filter
profiles. If you are building the same service with two different Go versions
to check for performance degradation you can label the profiles with
<code class="highlighter-rouge">go=1.13.4</code> for example.</li>
</ul>

<p>The article has way more content but that’s enough. You can keep reading with
only this information.</p>

<h2 id="kubernetes">Kubernetes</h2>

<p>As you know at InfluxData we use Kubernetes, our services already expose the
<a href="https://golang.org/pkg/net/http/pprof/">pprof HTTP handler</a> and we can not
instrument all the services with the Profefe SDK, for those reasons we had to
write our own collectors capable of getting pprof profiles via the Kubernetes
API and to push them into Profefe. That’s why we decided to go with a different
approach. I wrote a project called
<a href="https://github.com/profefe/kube-profefe">kube-profefe</a>. It acts as a bridge
between the Profefe API and Kubernetes. The repository provides two different
binaries:</p>

<ul>
  <li>A kubectl plugin that you can install (even via krew) that servers useful
utilities to interact with the profefe API (profefe at the moment does not
have a CLI) and to capture profiles from running pod.</li>
  <li>A collector that can run as a cronjob, it goes pod by pod looking for profiles
to collect and it will push them to Profefe.</li>
</ul>

<h2 id="architecture">Architecture</h2>

<p>In order to configure the collector or to capture profiles from a running
container, it leverages pod annotations. Only the pods with the annotation
<code class="highlighter-rouge">pprof.com/enable=true</code> will be taken into consideration from kube-profefe.
Other annotations are optional or they have default values. This one is the
unique one that has to be set to make kube-profefe aware of your pod.</p>

<p>The example above shows a Pod spec that enables profefe capabilities:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">influxdb-v2</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="s2">"</span><span class="s">profefe.com/enable"</span><span class="pi">:</span> <span class="s2">"</span><span class="s">true"</span>
    <span class="s2">"</span><span class="s">profefe.com/port"</span><span class="pi">:</span> <span class="s2">"</span><span class="s">9999"</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">influxdb</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">quay.io/influxdb/influxdb:2.0.0-alpha</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">9999</span>
</code></pre></div></div>

<p>As you can see there are other annotations such as <code class="highlighter-rouge">profefe.com/port</code> by default
is 6060. In this case it is pointed to 9999 because that’s where the pprof HTTP
handler runs in InfluxDB v2.  A full list of annotations is maintained in the
project’s README.md.</p>

<p>There is not a lot more to know about the underling mechanism that enpowers
kube-profefe, we are gonna deep dive on both components: the kubectl plugin and
the collector.</p>

<h2 id="kubectl-profefe-the-kubectl-plugin">Kubectl-profefe: the kubectl plugin</h2>

<p>A kubectl plugin is nothing more than a binary located in your $PATH with the
prefix name “kubectl-”. In my case the binary is released with the name
kubectl-profefe, when located in your $PATH you will be able to run a command
like:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl profefe <span class="nt">--help</span>
It is a kubectl plugin that you can use to retrieve and manage profiles <span class="k">in </span>Go.

Usage:
  kubectl-profefe <span class="o">[</span>flags]
  kubectl-profefe <span class="o">[</span><span class="nb">command</span><span class="o">]</span>

Available Commands:
  capture     Capture gathers profiles <span class="k">for </span>a pod or a <span class="nb">set </span>of them. If can filter by namespace and via label selector.
  get         Display one or many resources
  <span class="nb">help        </span>Help about any <span class="nb">command
  </span>load        Load a profile you have locally to profefe

Flags:
  <span class="nt">-A</span>, <span class="nt">--all-namespaces</span>                 If present, list the requested object<span class="o">(</span>s<span class="o">)</span> across all namespaces. Namespace <span class="k">in </span>current context is ignored even <span class="k">if </span>specified with <span class="nt">--namespace</span><span class="nb">.</span>
      <span class="nt">--as</span> string                      Username to impersonate <span class="k">for </span>the operation
      <span class="nt">--as-group</span> stringArray           Group to impersonate <span class="k">for </span>the operation, this flag can be repeated to specify multiple groups.
      <span class="nt">--cache-dir</span> string               Default HTTP cache directory <span class="o">(</span>default <span class="s2">"/home/gianarb/.kube/http-cache"</span><span class="o">)</span>
      <span class="nt">--certificate-authority</span> string   Path to a cert file <span class="k">for </span>the certificate authority
      <span class="nt">--client-certificate</span> string      Path to a client certificate file <span class="k">for </span>TLS
      <span class="nt">--client-key</span> string              Path to a client key file <span class="k">for </span>TLS
      <span class="nt">--cluster</span> string                 The name of the kubeconfig cluster to use
      <span class="nt">--context</span> string                 The name of the kubeconfig context to use
  <span class="nt">-f</span>, <span class="nt">--filename</span> strings               identifying the resource.
  <span class="nt">-h</span>, <span class="nt">--help</span>                           <span class="nb">help </span><span class="k">for </span>kubectl-profefe
      <span class="nt">--insecure-skip-tls-verify</span>       If <span class="nb">true</span>, the server<span class="s1">'s certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.
  -n, --namespace string               If present, the namespace scope for this CLI request
  -R, --recursive                      Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory. (default true)
      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don'</span>t timeout requests. <span class="o">(</span>default <span class="s2">"0"</span><span class="o">)</span>
  <span class="nt">-l</span>, <span class="nt">--selector</span> string                Selector <span class="o">(</span>label query<span class="o">)</span> to filter on, supports <span class="s1">'='</span>, <span class="s1">'=='</span>, and <span class="s1">'!='</span>.<span class="o">(</span>e.g. <span class="nt">-l</span> <span class="nv">key1</span><span class="o">=</span>value1,key2<span class="o">=</span>value2<span class="o">)</span>
  <span class="nt">-s</span>, <span class="nt">--server</span> string                  The address and port of the Kubernetes API server
      <span class="nt">--token</span> string                   Bearer token <span class="k">for </span>authentication to the API server
      <span class="nt">--user</span> string                    The name of the kubeconfig user to use

Use <span class="s2">"kubectl-profefe [command] --help"</span> <span class="k">for </span>more information about a command.
</code></pre></div></div>

<p>This output should look very familiar to you, there are a lot of options usable
with any other kubectl native command. Mainly around authentication: –user,
–server, –kubeconfig, –client-certificate… Or around pod selection: -l,
–selector, -n, –namespace, –all-namespaces. If you are curious about how to
write a friendly kubectl plugin I wrote <a href="https://gianarb.it/blog/kubectl-flags-in-your-plugin">“kubectl flags in your
plugin”</a> check it out.</p>

<p>This plugin, even if it is not native, uses the same authentication mechanism in
use from the kubectl so, where ever the kubectl works, this plugin should work
as well.</p>

<p>The pod selectors -l, -n, for example, are useful when running the command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl profefe capture
</code></pre></div></div>

<p>Capture, as the name suggests, goes straight to one or more pods and it
downloads or pushes to profefe various profiles. It is very flexible, you can
capture pprof profiles from a specific pod (or multiple pods) by ID:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl profefe capture &lt;pod-id&gt;,&lt;pod-id&gt;...
</code></pre></div></div>

<p><em>NB: just remember to use the namespace where the pods are running with the flag
-n or –namespace.</em></p>

<p>You can use the pod selectors to collect multiple profiles:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl profefe capture -n web
</code></pre></div></div>

<p>Captures profiles from all the pod with the pprof.com/enable=true annotation
running in the pod namespace and it will store them under the <code class="highlighter-rouge">/tmp</code> directory.
You can change the output directory with <code class="highlighter-rouge">--output-dir</code>. If you do not want to
store them locally you can push them to profefe specifying its location via
<code class="highlighter-rouge">--profefe-hostport</code>.</p>

<p>The are other combinations for the capture command and you can get profiles from
profefe, I will leave the rest to you!</p>

<p class="text-center"><img src="/img/stopwatch.jpg" alt="" class="img-fluid" /></p>

<p class="small text-center">Hero image via <a href="https://pixabay.com/illustrations/time-time-management-stopwatch-3216244/">Pixabay</a></p>

<h2 id="kprofefe-the-collector">Kprofefe: the collector</h2>

<p>The main responsability for the collector is to make the continuous profiling
magic to happen! It uses the same mechanism we already saw for the capture
kubectl plugin but it is a single binary and it can run as a cronjob.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: kprofefe-allnamespaces
  namespace: profefe
spec:
  concurrencyPolicy: Replace
  jobTemplate:
    metadata:
    spec:
      template:
        spec:
          containers:
          - args:
            - --all-namespaces
            - --profefe-hostport
            - http://profefe-collector:10100
            image: profefe/kprofefe:v0.0.8
            imagePullPolicy: IfNotPresent
            name: kprofefe
          restartPolicy: Never
          serviceAccount: kprofefe-all-namespaces
          serviceAccountName: kprofefe-all-namespaces
  schedule: '*/10 * * * *'
  successfulJobsHistoryLimit: 3
</code></pre></div></div>

<p>You can run a single cronjob that will over all the pods across all the
namespaces or you can deploy multiple cronjobs, playing with the label selector
(-l) and the namespace selector (-n) you can configure the ownership for every
running cronjob. The reasons to split in multiple cronjobs can be:</p>

<ul>
  <li>Scalability: one cronjob is not enough, so you can have one per namespace
for example</li>
  <li>Time segmentation: if you have a single cronjob it means that all the pods
profiles will get captured with the same frequency, but you will may want to
get high frequent profiles for a specific subset of applications and less
dencity for others.</li>
</ul>

<p>Documentation about <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">“Label and
Selector”</a>
for your reference.</p>

<p><em>Note: serviceAccount is required only if you have RBAC enabled (you should)
because the collector needs access to Kubernetes API to list/view pods across
all namespaces in this case.</em></p>

<h2 id="conclusion">Conclusion</h2>

<p>There is a lot to do in both the collector and kubectl plugins. I would like to
add logs and monitoring to the collector for example. The kubectl plugin get
profiles command needs some love, ideally using the same format that <code class="highlighter-rouge">kubectl
get</code> has via
<a href="https://github.com/kubernetes/cli-runtime/tree/master/pkg/printers">kubernetes/cli-runtime/pkg/printers</a>.
Try, contribute and <a href="https://twitter.com/gianarb">let me know</a>!</p>

            </div>
        </div>

        <div class="row mt-3">
            <div class="col-md-12">
                <div id="disqus_thread"></div>
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            </div>
        </div>

    </div>
</div>

<script>
var disqus_config = function () {
    this.page.url = 'https://gianarb.it/blog/continuous-profiling-go-apps-in-kubernetes';
    this.page.identifier = 'https://gianarb.it/blog/continuous-profiling-go-apps-in-kubernetes';
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://gianarbdeveloper.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

        <div class="footer text-center bg-dark text-light">
    <div class="container">
        <div class="row">
            <div class="col-md-12 small">
                last update December 22, 2020 ·
                <a href="https://twitter.com/gianarb" target="_blank">twitter.com/gianarb</a> ·
                <a href="https://github.com/gianarb" target="_blank">github.com/gianarb</a> ·
                <a href="https://twitch.tv/gianarb" target="_blank">twitch.tv/gianarb</a> ·
                <a href="/atom.xml">Atom</a>
            </div>
        </div>
    </div>
</div>

        <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/bash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/dockerfile.min.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/go.min.js"></script>
        <script src="/js/custom.js"></script>

        <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
